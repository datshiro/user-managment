
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">app/cmd/root.go (0.0%)</option>
				
				<option value="file1">app/cmd/server.go (0.0%)</option>
				
				<option value="file2">app/cmd/version.go (0.0%)</option>
				
				<option value="file3">app/internal/consts/errors.go (40.7%)</option>
				
				<option value="file4">app/internal/handler/login/handler.go (54.5%)</option>
				
				<option value="file5">app/internal/handler/login/request.go (85.7%)</option>
				
				<option value="file6">app/internal/handler/register/handler.go (64.7%)</option>
				
				<option value="file7">app/internal/handler/register/request.go (88.5%)</option>
				
				<option value="file8">app/internal/infras/database/db.go (0.0%)</option>
				
				<option value="file9">app/internal/infras/database/option.go (0.0%)</option>
				
				<option value="file10">app/internal/infras/database/postgres_connection.go (0.0%)</option>
				
				<option value="file11">app/internal/interfaces/app/app.go (0.0%)</option>
				
				<option value="file12">app/internal/interfaces/app/middlewares/error.go (80.0%)</option>
				
				<option value="file13">app/internal/interfaces/app/option.go (0.0%)</option>
				
				<option value="file14">app/internal/interfaces/entities/user.go (100.0%)</option>
				
				<option value="file15">app/internal/interfaces/repositories/user.go (0.0%)</option>
				
				<option value="file16">app/internal/interfaces/usecases/usecases.go (0.0%)</option>
				
				<option value="file17">app/internal/interfaces/usecases/user/user.go (0.0%)</option>
				
				<option value="file18">app/internal/mocks/app/Server.go (0.0%)</option>
				
				<option value="file19">app/internal/mocks/repositories/UserRepository.go (0.0%)</option>
				
				<option value="file20">app/internal/mocks/usecases/user/UserUsecase.go (44.9%)</option>
				
				<option value="file21">app/internal/models/user.go (0.0%)</option>
				
				<option value="file22">app/internal/utils/password.go (0.0%)</option>
				
				<option value="file23">app/internal/utils/request.go (50.0%)</option>
				
				<option value="file24">app/internal/utils/response.go (66.7%)</option>
				
				<option value="file25">app/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

var (
        rootCmd = &amp;cobra.Command{}
)

func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "app/internal/interfaces/app"
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/caarlos0/env/v11"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

func init() <span class="cov0" title="0">{
        // Load environment variables
        viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err == nil </span><span class="cov0" title="0">{
                fmt.Println("Using config file:", viper.ConfigFileUsed())
        }</span>

        // serverCommand.Flags().IntVarP(&amp;serverCfg.Port, "port", "p", serverCfg.Port, "port number to run on")
        // serverCommand.Flags().StringVar(&amp;serverCfg.ApiPrefix, "prefix", serverCfg.ApiPrefix, "API prefix")
        <span class="cov0" title="0">rootCmd.AddCommand(serverCommand)</span>
}

var (
        err       error

        serverCommand = &amp;cobra.Command{
                Use:   "server",
                Short: "Run App API Server",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        server := app.NewApp()

                        // Create a signal channel and start server in a goroutine
                        signChan := make(chan os.Signal, 1)
                        go func() </span><span class="cov0" title="0">{
                                if err := server.Start(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                        log.Fatalf("server.Start: %v", err)
                                }</span>
                        }()

                        // Listen to terminate signal from system or os
                        <span class="cov0" title="0">signal.Notify(signChan, os.Interrupt, syscall.SIGTERM)
                        &lt;-signChan
                        log.Println("shutting down")

                        waitTime := 2 * time.Second
                        ctx, cancel := context.WithTimeout(context.Background(), waitTime)
                        defer func() </span><span class="cov0" title="0">{
                                log.Println("Closing Database connection!")
                                cancel()
                        }</span>()

                        // Stop server
                        <span class="cov0" title="0">log.Println("Stopping http server....")
                        if err := server.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                                log.Println("Halted active connections")
                        }</span>
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                log.Printf("timeout for %v seconds", waitTime)</span>
                        }
                        <span class="cov0" title="0">log.Printf("Shudown completed!")</span>
                },
        }
)

func LoadConfig() (app.Opts, error) <span class="cov0" title="0">{
        c := app.Opts{}

        if err := env.Parse(&amp;c); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%+v\n", err)
        }</span>
        <span class="cov0" title="0">log.Printf("%+v\n", c)
        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(versionCmd)
}</span>

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print the version number of app",
        Long:  `All software has versions. This is an api server version`,
  Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
    fmt.Println("App 1.0.0")
  }</span>,
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package consts

import (
        "fmt"
        "net/http"
)

// Custom error type for internal service
// this struct must be initialize via 
type CustomError struct {
        root     error
        err      error
        args     []interface{}
        tags     map[string]interface{}
        httpCode int
}

func NewError(err error, args ...interface{}) CustomError <span class="cov8" title="1">{
        return CustomError{root: err, err: err, tags: map[string]interface{}{}}
}</span>

// Error message is combination of message, args and tags
func (e CustomError) Error() string <span class="cov8" title="1">{
        var msg string
        re, ok := e.root.(CustomError)
        if ok </span><span class="cov0" title="0">{
                msg += fmt.Sprintf("%v; ", re.Error())
        }</span>
        <span class="cov8" title="1">if e.err != nil </span><span class="cov8" title="1">{
                msg += fmt.Sprintf("%v; ", e.err.Error())
        }</span>
        <span class="cov8" title="1">for _, arg := range e.args </span><span class="cov0" title="0">{
                msg += fmt.Sprintf(" %+v; ", arg)
        }</span>

        <span class="cov8" title="1">return msg</span>
}

// Add tag to error for additional info, which useful for log and tracing
func (e CustomError) WithTag(key string, value interface{}) CustomError <span class="cov0" title="0">{
        e.tags[key] = value
        return e
}</span>

// set root cause error
func (e CustomError) WithRootCause(err error) CustomError <span class="cov0" title="0">{
        e.root = err
        return e
}</span>

func (e CustomError) Details() string <span class="cov0" title="0">{
        var msg string
        if e.root != nil </span><span class="cov0" title="0">{
                msg += e.root.Error()
        }</span>
        <span class="cov0" title="0">for tag, value := range e.tags </span><span class="cov0" title="0">{
                msg += fmt.Sprintf("; %s=%+v", tag, value)
        }</span>
        <span class="cov0" title="0">return msg</span>
}

// Set HTTP Status Code which will set to header in response
func (e CustomError) WithHttpCode(code int) CustomError <span class="cov0" title="0">{
        e.httpCode = code
        return e
}</span>

// Set HTTP Status Code which will set to header in response
func (e CustomError) GetCode() int <span class="cov8" title="1">{
        if e.httpCode == 0 </span><span class="cov8" title="1">{
                return http.StatusBadRequest // 400 as default
        }</span>
        <span class="cov0" title="0">return e.httpCode</span>
}

// Init error with error type
func withError(err error, args ...interface{}) CustomError <span class="cov0" title="0">{
        return NewError(err, args...)
}</span>

// Init error with string message
func withMessage(msg string, args ...interface{}) CustomError <span class="cov8" title="1">{
        return NewError(fmt.Errorf(msg), args...)
}</span>

var (
        ErrInvalidRequest        = withMessage("Invalid request")
        ErrCreateFailure         = withMessage("Create failure")
        ErrLoginFailure          = withMessage("Login Failure")
        ErrDataNotFound          = withMessage("Requesting resource not found")
        ErrMissingCredentialInfo = withMessage("account info cannot be empty, please provide username, email or phone number")
        ErrPasswordCannotBeEmpty = withMessage("password cannot be empty")
)
</pre>
		
		<pre class="file" id="file4" style="display: none">package login

import (
        "app/internal/consts"
        "app/internal/handler"
        "app/internal/interfaces/usecases/user"
        "app/internal/models"
        "app/internal/utils"
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

func NewHandler(userUC user.UserUsecase) handler.Handler <span class="cov8" title="1">{
        return loginHandler{NewRequest: NewRequest, UserUsecase: userUC}
}</span>

type loginHandler struct {
        NewRequest  func() Request
        UserUsecase user.UserUsecase
}

func (h loginHandler) Handle(c *gin.Context) <span class="cov8" title="1">{
        req := h.NewRequest()
        if err := req.Bind(c); err != nil </span><span class="cov0" title="0">{
                c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">if err := req.Validate(); err != nil </span><span class="cov0" title="0">{
                c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">var (
                user *models.User
                err  error
        )

        switch req.LoginType() </span>{
        case consts.UserNameLoginType:<span class="cov8" title="1">
                user, err = h.UserUsecase.LoginWithUsername(c.Request.Context(), req.GetAccount(), req.GetPassword())</span>
        case consts.EmailLoginType:<span class="cov8" title="1">
                user, err = h.UserUsecase.LoginWithEmail(c.Request.Context(), req.GetAccount(), req.GetPassword())</span>
        case consts.PhoneNumberLoginType:<span class="cov8" title="1">
                user, err = h.UserUsecase.LoginWithPhone(c.Request.Context(), req.GetAccount(), req.GetPassword())</span>
        default:<span class="cov0" title="0">
                c.Error(consts.NewError(fmt.Errorf("provided login does not support")).
                        WithRootCause(err).
                        WithTag("Method", "LoginUser").
                        WithTag("data", req))</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        c.Error(consts.ErrDataNotFound.WithHttpCode(http.StatusNotFound).WithTag("Method", "LoginUser").WithTag("data", req))
                        return
                }</span>
                <span class="cov0" title="0">c.Error(consts.ErrLoginFailure.WithRootCause(err).WithTag("Method", "LoginUser").WithTag("data", req))
                return</span>
        }

        <span class="cov8" title="1">utils.ResponseWithJSON(c, toResponse(user))</span>
}

func toResponse(user *models.User) response <span class="cov8" title="1">{
  return response{
    Fullname   : user.Fullname,
    PhoneNumber: user.PhoneNumber,
    Email      : user.Email,
    Username   : user.Username,
    Birthday   : user.Birthday,
    LatestLogin: user.LatestLogin,
  }
}</span>

type response struct {
        Fullname    string    `json:"fullname"`
        PhoneNumber string    `json:"phone_number"`
        Email       string    `json:"email"`
        Username    string    `json:"username"`
        Birthday    time.Time `json:"birthday"`
        LatestLogin time.Time `json:"latest_login"`
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package login

import (
        "app/internal/consts"
        "app/internal/handler"
        "app/internal/utils"

        "github.com/gin-gonic/gin"
)

type Request interface {
        handler.Request
        GetAccount() string
        GetPassword() string
  LoginType() consts.LoginType
}

func NewRequest() Request <span class="cov8" title="1">{
        return &amp;request{}
}</span>

type request struct {
        Username    string `form:"username"  json:"username"`
        Email       string `form:"email"  json:"email"`
        PhoneNumber string `form:"phone_number" json:"phone_number"`
        Password    string `form:"password" json:"password"`
        account     string // Account value for authenticating
        loginType   consts.LoginType // Username | Email | PhoneNumber
}

func (r *request) Bind(c *gin.Context) error <span class="cov8" title="1">{
        if err := utils.BindRequest(c, r, "LoginHandler"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if r.Username != "" </span><span class="cov8" title="1">{
                r.account = r.Username
    r.loginType = consts.UserNameLoginType
        }</span>
        <span class="cov8" title="1">if r.Email != "" </span><span class="cov8" title="1">{
                r.account = r.Email
    r.loginType = consts.EmailLoginType
        }</span>
        <span class="cov8" title="1">if r.PhoneNumber != "" </span><span class="cov8" title="1">{
                r.account = r.PhoneNumber
    r.loginType = consts.PhoneNumberLoginType
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *request) Validate() error <span class="cov8" title="1">{
        if r.account == "" &amp;&amp; r.loginType == 0 </span><span class="cov0" title="0">{
                return consts.ErrMissingCredentialInfo
        }</span>
        <span class="cov8" title="1">if r.Password == "" </span><span class="cov0" title="0">{
    return consts.ErrPasswordCannotBeEmpty
        }</span>
  <span class="cov8" title="1">return nil</span>
}

func (r *request) GetAccount() string <span class="cov8" title="1">{
        return r.account
}</span>

func (r *request) GetPassword() string <span class="cov8" title="1">{
        return r.Password
}</span>

func (r *request) LoginType() consts.LoginType <span class="cov8" title="1">{
  return r.loginType
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package register

import (
        "app/internal/consts"
        "app/internal/handler"
        "app/internal/interfaces/usecases/user"
        "app/internal/utils"
        "fmt"

        "github.com/gin-gonic/gin"
)

func NewHandler(userUC user.UserUsecase) handler.Handler <span class="cov8" title="1">{
        return registerHandler{NewRequest: NewRequest, UserUsecase: userUC}
}</span>

type registerHandler struct {
        NewRequest func() Request
  UserUsecase user.UserUsecase
}

func (h registerHandler) Handle(c *gin.Context) <span class="cov8" title="1">{
        req := h.NewRequest()
        if err := req.Bind(c); err != nil </span><span class="cov0" title="0">{
                c.Error(err)
    return 
        }</span>

        <span class="cov8" title="1">if err := req.Validate(); err != nil </span><span class="cov8" title="1">{
                c.Error(err)
    return 
        }</span>

  <span class="cov8" title="1">userData , err := req.toData()
  if err !=nil </span><span class="cov0" title="0">{
                c.Error(consts.ErrInvalidRequest.WithRootCause(err).WithTag("Method", "ConvertRequestData").WithTag("request", fmt.Sprintf("%+v", req)))
    return 
  }</span>

  <span class="cov8" title="1">user, err := h.UserUsecase.RegisterUser(c.Request.Context(), userData)
  if err !=nil </span><span class="cov0" title="0">{
                c.Error(consts.ErrCreateFailure.WithRootCause(err).WithTag("Method", "RegisterUser").WithTag("data", userData))
    return 
  }</span>

        <span class="cov8" title="1">utils.ResponseWithJSON(c, user)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package register

import (
        "app/internal/consts"
        "app/internal/handler"
        "app/internal/interfaces/entities"
        "app/internal/utils"
        "encoding/json"
        "time"

        "github.com/gin-gonic/gin"
)

type Request interface {
        handler.Request
        Marshal() ([]byte, error)
        toData() (entities.UserData, error)
}

func NewRequest() Request <span class="cov8" title="1">{
        return &amp;request{}
}</span>

type request struct {
        Username    string           `form:"username"  json:"username"`
        Email       string           `form:"email"  json:"email"`
        Fullname    string           `form:"fullname" json:"fullname"`
        PhoneNumber string           `form:"phone_number" json:"phone_number"`
        Password    string           `form:"password" json:"password"`
        Birthday    time.Time        `form:"birthday" json:"birthday"`
        LatestLogin time.Time        `form:"latest_login" json:"latest_login"`
        account     string           // Account value for authenticating
        loginType   consts.LoginType // Username | Email | PhoneNumber
}

func (r *request) Bind(c *gin.Context) error <span class="cov8" title="1">{
        if err := utils.BindRequest(c, r, "LoginHandler"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if r.Username != "" </span><span class="cov8" title="1">{
                r.account = r.Username
                r.loginType = consts.UserNameLoginType
        }</span>
        <span class="cov8" title="1">if r.Email != "" </span><span class="cov8" title="1">{
                r.account = r.Email
                r.loginType = consts.EmailLoginType
        }</span>
        <span class="cov8" title="1">if r.PhoneNumber != "" </span><span class="cov8" title="1">{
                r.account = r.PhoneNumber
                r.loginType = consts.PhoneNumberLoginType
        }</span>
        <span class="cov8" title="1">return nil</span>

}

func (r *request) Validate() error <span class="cov8" title="1">{
        if r.account == "" &amp;&amp; r.loginType == 0 </span><span class="cov8" title="1">{
                return consts.ErrMissingCredentialInfo
        }</span>
        <span class="cov8" title="1">if r.Password == "" </span><span class="cov8" title="1">{
    return consts.ErrPasswordCannotBeEmpty
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *request) Marshal() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(r)
}</span>

func (r *request) toData() (entities.UserData, error) <span class="cov8" title="1">{
        b, err := r.Marshal()
        if err != nil </span><span class="cov0" title="0">{
                return entities.UserData{}, err
        }</span>

        <span class="cov8" title="1">data := entities.UserData{}
        if err := json.Unmarshal(b, &amp;data); err != nil </span><span class="cov0" title="0">{
                return entities.UserData{}, err
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package database

import (
        "app/internal/models"
        "log"

        "gorm.io/gorm"
)

type DatabaseConnection interface {
        Connect() (*gorm.DB, error)
}

func NewPostgresConnection() *gorm.DB <span class="cov0" title="0">{
        o := loadOpts()

        dbConnection := &amp;PostgresConnection{Opts: o}

        postgresDbc, err := dbConnection.Connect()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect database ; %v", err)
        }</span>

        // Migrate the schema
        <span class="cov0" title="0">postgresDbc.AutoMigrate(&amp;models.User{})
        // End of migration

        return postgresDbc</span>
}

func ClosePostgresConnection() error <span class="cov0" title="0">{
        db, err := postgresDbc.DB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">db.Close()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "fmt"
        "log"

        "github.com/caarlos0/env/v11"
        "gorm.io/gorm"
)

type Opts struct {
        DB        string `env:"DATABASE_DB"`
        User      string `env:"DATABASE_USER"`
        Password  string `env:"DATABASE_PASSWORD"`
        Host      string `env:"DATABASE_HOST"`
        Port      string `env:"DATABASE_PORT"`
        SSLMode   string `env:"DATABASE_SSL_MODE" default:"disable"`
        TimeZone  string `env:"DATABASE_TIME_ZONE" default:"Asia/Shanghai"`
        dialector gorm.Dialector
}
type OptFunc func(*Opts)

func loadOpts() Opts <span class="cov0" title="0">{
        c := Opts{}

        if err := env.Parse(&amp;c); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%+v\n", err)
        }</span>
  <span class="cov0" title="0">fmt.Printf("%+v\n", c)
        return c</span>

}

func (opt *Opts) MakeConnect() (*gorm.DB, error) <span class="cov0" title="0">{
        db, err := gorm.Open(opt.dialector, &amp;gorm.Config{})
        return db, err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "fmt"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

var postgresDbc *gorm.DB

type PostgresConnection struct {
        Opts
}

func (p *PostgresConnection) Connect() (*gorm.DB, error) <span class="cov0" title="0">{
        dsn := "host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=%s"
        p.dialector = postgres.Open(fmt.Sprintf(dsn, p.Host, p.User, p.Password, p.DB, p.Port, p.SSLMode, p.TimeZone))
        client, err := p.MakeConnect()
        return client, err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package app

import (
        "app/internal/handler/login"
        "app/internal/handler/register"
        "app/internal/infras/database"
        "app/internal/interfaces/app/middlewares"
        "app/internal/interfaces/usecases"
        "context"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type App interface {
        Start() error
        Stop(ctx context.Context) error
}

type app struct {
        engine *gin.Engine
        srv    *http.Server
        cfg    Opts
        dbc    *gorm.DB
}

func (s *app) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return s.srv.Shutdown(ctx)
}</span>

func NewApp(opts ...OptFunc) App <span class="cov0" title="0">{
        engine := gin.Default()
        o := defaultOpts()

        for _, optFunc := range opts </span><span class="cov0" title="0">{
                optFunc(&amp;o)
        }</span>

        <span class="cov0" title="0">a := &amp;app{
                engine: engine,
                srv: &amp;http.Server{
                        Handler: engine,
                        Addr:    fmt.Sprintf(":%d", o.Port),
                },
        }

        if o.IsConnectDatabase </span><span class="cov0" title="0">{
                a.dbc = database.NewPostgresConnection()
        }</span>
        <span class="cov0" title="0">return a</span>
}

func (s *app) Start() error <span class="cov0" title="0">{
        // Middlwares
        s.engine.Use(gin.Recovery())
        s.engine.Use(middlewares.ErrorHandlerMiddleware())

        usecase := usecases.NewPostgresUsecase(s.dbc)

        // Routers
        routing(s.engine, s.cfg.ApiPrefix, usecase)

        return s.srv.ListenAndServe()
}</span>

func routing(engine *gin.Engine, apiPrefix string, usecase usecases.Usecases) <span class="cov0" title="0">{
        router := engine.Group(apiPrefix)

        router.POST("/register", register.NewHandler(usecase.UserUC).Handle)
        router.POST("/login", login.NewHandler(usecase.UserUC).Handle)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package middlewares

import (
        "app/internal/consts"
        "net/http"

        "github.com/gin-gonic/gin"
)

func ErrorHandlerMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                c.Next()

                errs := c.Errors
                if len(errs) &gt; 0 </span><span class="cov8" title="1">{
      // log.Println("errs", errs)
                        err, ok := errs[0].Err.(consts.CustomError)
                        if ok </span><span class="cov8" title="1">{
                                // Log root error
                                // log.Printf("error details: %v", err.Details())
                                c.JSON(err.GetCode(), err.Error())
                                return
                        }</span>
                        // log.Printf("Unknown err %+v \n", err)
                        <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, err.Error())
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package app

import (
        "fmt"
        "log"

        "github.com/caarlos0/env/v11"
)

type Opts struct {
        Port              int    `env:"PORT" envDefault:"3333" json:"port"`
        RedisUrl          string `env:"REDIS_URL" json:"redis_url"`
        ApiPrefix         string `env:"API_PREFIX" envPrefix:"api" json:"api_prefix"`
        IsConnectDatabase bool   `env:"IS_CONNECT_DATABASE" envDefault:"false"`
}

func defaultOpts() Opts <span class="cov0" title="0">{
        c := Opts{
                Port:      3000,
                RedisUrl:  "redis://0.0.0.0:6379",
                ApiPrefix: "api",
    IsConnectDatabase: false,
        }

        if err := env.Parse(&amp;c); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%+v\n", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("%+v\n", c)

        return c</span>
}

type OptFunc func(*Opts)

func WithPort(port int) OptFunc <span class="cov0" title="0">{
        return func(c *Opts) </span><span class="cov0" title="0">{
                c.Port = port
        }</span>
}

func WithDatabase(isConnectDatabase bool) OptFunc <span class="cov0" title="0">{
        return func(c *Opts) </span><span class="cov0" title="0">{
                c.IsConnectDatabase = isConnectDatabase
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package entities

import (
        "app/internal/models"
        "time"
)

type UserData struct {
        Fullname    string    `json:"fullname"`
        PhoneNumber string    `json:"phone_number"`
        Email       string    `json:"email"`
        Username    string    `json:"username"`
        Password    string    `json:"password"`
        Birthday    time.Time `json:"birthday"`
        LatestLogin time.Time `json:"latest_login"`
}

func (u UserData) ToModel() (*models.User) <span class="cov8" title="1">{
  return &amp;models.User{
    Fullname: u.Fullname,
    PhoneNumber: u.PhoneNumber,
    Email: u.Email,
    Username: u.Username,
    Password: u.Password,
    Birthday: u.Birthday,
    LatestLogin: u.LatestLogin,
  }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package repositories

import (
        "app/internal/consts"
        "app/internal/models"
        "app/internal/utils"
        "context"
        "errors"
        "fmt"
        "time"

        "gorm.io/gorm"
)

type UserRepository interface {
        CreateUser(ctx context.Context, userObject *models.User) (*models.User, error)
        GetUserByID(ctx context.Context, id int) (*models.User, error)
        UpdateLastLogin(ctx context.Context, id uint) (bool, error)
        GetUserByEmail(ctx context.Context, email string, password string) (*models.User, error)
        GetUserByUsername(ctx context.Context, username string, password string) (*models.User, error)
        GetUserByPhone(ctx context.Context, phone string, password string) (*models.User, error)
}

func NewRepo(dbc *gorm.DB) UserRepository <span class="cov0" title="0">{
        return &amp;userRepo{dbc}
}</span>

type userRepo struct {
        dbc *gorm.DB
}

func (repo *userRepo) CreateUser(ctx context.Context, data *models.User) (*models.User, error) <span class="cov0" title="0">{
        tx := repo.dbc.Begin()
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Check user existence
        <span class="cov0" title="0">var existed bool
        err := tx.Model(&amp;models.User{}).
                Select("count(*) &gt; 0").
                Where("username = ? OR email = ? OR phone_number = ?", data.Username, data.Email, data.PhoneNumber).
                Find(&amp;existed).
                Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, consts.NewError(fmt.Errorf("user already existed")).WithTag("Method", "CreateUser")
                }</span> else<span class="cov0" title="0"> {
                        return nil, consts.NewError(fmt.Errorf("something went wrong. Please try again; %+v", err)).WithTag("Method", "Commit")
                }</span>
        }
        <span class="cov0" title="0">if existed </span><span class="cov0" title="0">{
                return nil, consts.NewError(fmt.Errorf("user already existed")).WithTag("Method", "CreateUser")
        }</span>

        <span class="cov0" title="0">result := tx.Create(data)
        if result.Error != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, consts.NewError(fmt.Errorf("something went wrong. Please try again; %+v", err)).WithTag("Method", "Commit")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

func (repo *userRepo) GetUserByID(ctx context.Context, id int) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        result := repo.dbc.First(user, id)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (repo *userRepo) UpdateLastLogin(ctx context.Context, id uint) (bool, error) <span class="cov0" title="0">{
        result := repo.dbc.Model(&amp;models.User{}).Where("id = ?", id).Update("latest_login", time.Now())
        if result.Error != nil </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (repo *userRepo) GetUserByEmail(ctx context.Context, email string, password string) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        result := repo.dbc.First(user, "email = ?", email)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if ok := utils.CheckPasswordHash(password, user.Password); !ok </span><span class="cov0" title="0">{
                return nil, consts.NewError(fmt.Errorf("credential verification failure; wrong password")).WithTag("Method", "GetUserByEmail")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (repo *userRepo) GetUserByPhone(ctx context.Context, phone string, password string) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        result := repo.dbc.First(user, "phone_number = ?", phone)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if ok := utils.CheckPasswordHash(password, user.Password); !ok </span><span class="cov0" title="0">{
                return nil, consts.NewError(fmt.Errorf("credential verification failure; wrong password")).WithTag("Method", "GetUserByEmail")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}

func (repo *userRepo) GetUserByUsername(ctx context.Context, username string, password string) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        result := repo.dbc.First(user, "username = ?", username)
        if result.Error != nil </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>
        <span class="cov0" title="0">if ok := utils.CheckPasswordHash(password, user.Password); !ok </span><span class="cov0" title="0">{
                return nil, consts.NewError(fmt.Errorf("credential verification failure; wrong password")).WithTag("Method", "GetUserByEmail")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package usecases

import (
        "app/internal/interfaces/repositories"
        "app/internal/interfaces/usecases/user"

        "gorm.io/gorm"
)

type Usecases struct {
  UserUC user.UserUsecase 
}

func NewPostgresUsecase(dbc *gorm.DB) Usecases <span class="cov0" title="0">{
  return Usecases{
    UserUC: user.NewUseCase(repositories.NewRepo(dbc)),
  }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package user

import (
        "app/internal/interfaces/entities"
        "app/internal/interfaces/repositories"
        "app/internal/models"
        "context"
)

type UserUsecase interface {
        LoginWithEmail(ctx context.Context, email string, password string) (*models.User, error)
        LoginWithUsername(ctx context.Context, username string, password string) (*models.User, error)
        LoginWithPhone(ctx context.Context, phone string, password string) (*models.User, error)
        RegisterUser(ctx context.Context, data entities.UserData) (*models.User, error)
}

func NewUseCase(repo repositories.UserRepository) UserUsecase <span class="cov0" title="0">{
        return &amp;userUsecase{repo: repo}
}</span>

type userUsecase struct {
        repo repositories.UserRepository
}

func (uc *userUsecase) LoginWithEmail(ctx context.Context, email string, password string) (*models.User, error) <span class="cov0" title="0">{
        user, err := uc.repo.GetUserByEmail(ctx, email, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_, _ = uc.repo.UpdateLastLogin(ctx, user.ID)
        return user, err</span>
}

func (uc *userUsecase) LoginWithUsername(ctx context.Context, username string, password string) (_ *models.User, _ error) <span class="cov0" title="0">{
        user, err := uc.repo.GetUserByUsername(ctx, username, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_, _ = uc.repo.UpdateLastLogin(ctx, user.ID)
        return user, err</span>
}

func (uc *userUsecase) LoginWithPhone(ctx context.Context, phone string, password string) (_ *models.User, _ error) <span class="cov0" title="0">{
        user, err := uc.repo.GetUserByPhone(ctx, phone, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_, _ = uc.repo.UpdateLastLogin(ctx, user.ID)
        return user, err</span>
}

func (uc *userUsecase) RegisterUser(ctx context.Context, data entities.UserData) (*models.User, error) <span class="cov0" title="0">{
        userModel := data.ToModel()
        // Hash Password implemented at BeforeCreate hook
        user, err := uc.repo.CreateUser(ctx, userModel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by mockery. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// Server is an autogenerated mock type for the Server type
type Server struct {
        mock.Mock
}

type Server_Expecter struct {
        mock *mock.Mock
}

func (_m *Server) EXPECT() *Server_Expecter <span class="cov0" title="0">{
        return &amp;Server_Expecter{mock: &amp;_m.Mock}
}</span>

// Start provides a mock function with given fields:
func (_m *Server) Start() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Start")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Server_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type Server_Start_Call struct {
        *mock.Call
}

// Start is a helper method to define mock.On call
func (_e *Server_Expecter) Start() *Server_Start_Call <span class="cov0" title="0">{
        return &amp;Server_Start_Call{Call: _e.mock.On("Start")}
}</span>

func (_c *Server_Start_Call) Run(run func()) *Server_Start_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *Server_Start_Call) Return(_a0 error) *Server_Start_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Server_Start_Call) RunAndReturn(run func() error) *Server_Start_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Stop provides a mock function with given fields: ctx
func (_m *Server) Stop(ctx context.Context) error <span class="cov0" title="0">{
        ret := _m.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Stop")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Server_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type Server_Stop_Call struct {
        *mock.Call
}

// Stop is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Server_Expecter) Stop(ctx interface{}) *Server_Stop_Call <span class="cov0" title="0">{
        return &amp;Server_Stop_Call{Call: _e.mock.On("Stop", ctx)}
}</span>

func (_c *Server_Stop_Call) Run(run func(ctx context.Context)) *Server_Stop_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *Server_Stop_Call) Return(_a0 error) *Server_Stop_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *Server_Stop_Call) RunAndReturn(run func(context.Context) error) *Server_Stop_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewServer creates a new instance of Server. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewServer(t interface {
        mock.TestingT
        Cleanup(func())
}) *Server <span class="cov0" title="0">{
        mock := &amp;Server{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by mockery. DO NOT EDIT.

package mocks

import (
        models "app/internal/models"
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// UserRepository is an autogenerated mock type for the UserRepository type
type UserRepository struct {
        mock.Mock
}

type UserRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *UserRepository) EXPECT() *UserRepository_Expecter <span class="cov0" title="0">{
        return &amp;UserRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateUser provides a mock function with given fields: ctx, userObject
func (_m *UserRepository) CreateUser(ctx context.Context, userObject *models.User) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, userObject)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateUser")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.User) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, userObject)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *models.User) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, userObject)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *models.User) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, userObject)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UserRepository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type UserRepository_CreateUser_Call struct {
        *mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userObject *models.User
func (_e *UserRepository_Expecter) CreateUser(ctx interface{}, userObject interface{}) *UserRepository_CreateUser_Call <span class="cov0" title="0">{
        return &amp;UserRepository_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, userObject)}
}</span>

func (_c *UserRepository_CreateUser_Call) Run(run func(ctx context.Context, userObject *models.User)) *UserRepository_CreateUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*models.User))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserRepository_CreateUser_Call) Return(_a0 *models.User, _a1 error) *UserRepository_CreateUser_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserRepository_CreateUser_Call) RunAndReturn(run func(context.Context, *models.User) (*models.User, error)) *UserRepository_CreateUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetUserByEmail provides a mock function with given fields: ctx, email, password
func (_m *UserRepository) GetUserByEmail(ctx context.Context, email string, password string) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, email, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByEmail")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, password)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, password)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, password)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UserRepository_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type UserRepository_GetUserByEmail_Call struct {
        *mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - password string
func (_e *UserRepository_Expecter) GetUserByEmail(ctx interface{}, email interface{}, password interface{}) *UserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        return &amp;UserRepository_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, email, password)}
}</span>

func (_c *UserRepository_GetUserByEmail_Call) Run(run func(ctx context.Context, email string, password string)) *UserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserRepository_GetUserByEmail_Call) Return(_a0 *models.User, _a1 error) *UserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserRepository_GetUserByEmail_Call) RunAndReturn(run func(context.Context, string, string) (*models.User, error)) *UserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetUserByID provides a mock function with given fields: ctx, id
func (_m *UserRepository) GetUserByID(ctx context.Context, id int) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByID")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UserRepository_GetUserByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByID'
type UserRepository_GetUserByID_Call struct {
        *mock.Call
}

// GetUserByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *UserRepository_Expecter) GetUserByID(ctx interface{}, id interface{}) *UserRepository_GetUserByID_Call <span class="cov0" title="0">{
        return &amp;UserRepository_GetUserByID_Call{Call: _e.mock.On("GetUserByID", ctx, id)}
}</span>

func (_c *UserRepository_GetUserByID_Call) Run(run func(ctx context.Context, id int)) *UserRepository_GetUserByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserRepository_GetUserByID_Call) Return(_a0 *models.User, _a1 error) *UserRepository_GetUserByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserRepository_GetUserByID_Call) RunAndReturn(run func(context.Context, int) (*models.User, error)) *UserRepository_GetUserByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetUserByPhone provides a mock function with given fields: ctx, phone, password
func (_m *UserRepository) GetUserByPhone(ctx context.Context, phone string, password string) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, phone, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByPhone")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, phone, password)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, phone, password)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, phone, password)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UserRepository_GetUserByPhone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByPhone'
type UserRepository_GetUserByPhone_Call struct {
        *mock.Call
}

// GetUserByPhone is a helper method to define mock.On call
//   - ctx context.Context
//   - phone string
//   - password string
func (_e *UserRepository_Expecter) GetUserByPhone(ctx interface{}, phone interface{}, password interface{}) *UserRepository_GetUserByPhone_Call <span class="cov0" title="0">{
        return &amp;UserRepository_GetUserByPhone_Call{Call: _e.mock.On("GetUserByPhone", ctx, phone, password)}
}</span>

func (_c *UserRepository_GetUserByPhone_Call) Run(run func(ctx context.Context, phone string, password string)) *UserRepository_GetUserByPhone_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserRepository_GetUserByPhone_Call) Return(_a0 *models.User, _a1 error) *UserRepository_GetUserByPhone_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserRepository_GetUserByPhone_Call) RunAndReturn(run func(context.Context, string, string) (*models.User, error)) *UserRepository_GetUserByPhone_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetUserByUsername provides a mock function with given fields: ctx, username, password
func (_m *UserRepository) GetUserByUsername(ctx context.Context, username string, password string) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, username, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByUsername")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username, password)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username, password)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username, password)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UserRepository_GetUserByUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByUsername'
type UserRepository_GetUserByUsername_Call struct {
        *mock.Call
}

// GetUserByUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - password string
func (_e *UserRepository_Expecter) GetUserByUsername(ctx interface{}, username interface{}, password interface{}) *UserRepository_GetUserByUsername_Call <span class="cov0" title="0">{
        return &amp;UserRepository_GetUserByUsername_Call{Call: _e.mock.On("GetUserByUsername", ctx, username, password)}
}</span>

func (_c *UserRepository_GetUserByUsername_Call) Run(run func(ctx context.Context, username string, password string)) *UserRepository_GetUserByUsername_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserRepository_GetUserByUsername_Call) Return(_a0 *models.User, _a1 error) *UserRepository_GetUserByUsername_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserRepository_GetUserByUsername_Call) RunAndReturn(run func(context.Context, string, string) (*models.User, error)) *UserRepository_GetUserByUsername_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateLastLogin provides a mock function with given fields: ctx, id
func (_m *UserRepository) UpdateLastLogin(ctx context.Context, id uint) (bool, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateLastLogin")</span>
        }

        <span class="cov0" title="0">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, uint) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, uint) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, uint) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UserRepository_UpdateLastLogin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateLastLogin'
type UserRepository_UpdateLastLogin_Call struct {
        *mock.Call
}

// UpdateLastLogin is a helper method to define mock.On call
//   - ctx context.Context
//   - id uint
func (_e *UserRepository_Expecter) UpdateLastLogin(ctx interface{}, id interface{}) *UserRepository_UpdateLastLogin_Call <span class="cov0" title="0">{
        return &amp;UserRepository_UpdateLastLogin_Call{Call: _e.mock.On("UpdateLastLogin", ctx, id)}
}</span>

func (_c *UserRepository_UpdateLastLogin_Call) Run(run func(ctx context.Context, id uint)) *UserRepository_UpdateLastLogin_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserRepository_UpdateLastLogin_Call) Return(_a0 bool, _a1 error) *UserRepository_UpdateLastLogin_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserRepository_UpdateLastLogin_Call) RunAndReturn(run func(context.Context, uint) (bool, error)) *UserRepository_UpdateLastLogin_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewUserRepository creates a new instance of UserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUserRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *UserRepository <span class="cov0" title="0">{
        mock := &amp;UserRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by mockery. DO NOT EDIT.

package mocks

import (
        entities "app/internal/interfaces/entities"
        context "context"

        mock "github.com/stretchr/testify/mock"

        models "app/internal/models"
)

// UserUsecase is an autogenerated mock type for the UserUsecase type
type UserUsecase struct {
        mock.Mock
}

type UserUsecase_Expecter struct {
        mock *mock.Mock
}

func (_m *UserUsecase) EXPECT() *UserUsecase_Expecter <span class="cov0" title="0">{
        return &amp;UserUsecase_Expecter{mock: &amp;_m.Mock}
}</span>

// LoginWithEmail provides a mock function with given fields: ctx, email, password
func (_m *UserUsecase) LoginWithEmail(ctx context.Context, email string, password string) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, email, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for LoginWithEmail")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, password)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, password)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, password)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UserUsecase_LoginWithEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginWithEmail'
type UserUsecase_LoginWithEmail_Call struct {
        *mock.Call
}

// LoginWithEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - password string
func (_e *UserUsecase_Expecter) LoginWithEmail(ctx interface{}, email interface{}, password interface{}) *UserUsecase_LoginWithEmail_Call <span class="cov0" title="0">{
        return &amp;UserUsecase_LoginWithEmail_Call{Call: _e.mock.On("LoginWithEmail", ctx, email, password)}
}</span>

func (_c *UserUsecase_LoginWithEmail_Call) Run(run func(ctx context.Context, email string, password string)) *UserUsecase_LoginWithEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserUsecase_LoginWithEmail_Call) Return(_a0 *models.User, _a1 error) *UserUsecase_LoginWithEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserUsecase_LoginWithEmail_Call) RunAndReturn(run func(context.Context, string, string) (*models.User, error)) *UserUsecase_LoginWithEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// LoginWithPhone provides a mock function with given fields: ctx, phone, password
func (_m *UserUsecase) LoginWithPhone(ctx context.Context, phone string, password string) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, phone, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for LoginWithPhone")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, phone, password)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, phone, password)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, phone, password)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UserUsecase_LoginWithPhone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginWithPhone'
type UserUsecase_LoginWithPhone_Call struct {
        *mock.Call
}

// LoginWithPhone is a helper method to define mock.On call
//   - ctx context.Context
//   - phone string
//   - password string
func (_e *UserUsecase_Expecter) LoginWithPhone(ctx interface{}, phone interface{}, password interface{}) *UserUsecase_LoginWithPhone_Call <span class="cov0" title="0">{
        return &amp;UserUsecase_LoginWithPhone_Call{Call: _e.mock.On("LoginWithPhone", ctx, phone, password)}
}</span>

func (_c *UserUsecase_LoginWithPhone_Call) Run(run func(ctx context.Context, phone string, password string)) *UserUsecase_LoginWithPhone_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserUsecase_LoginWithPhone_Call) Return(_a0 *models.User, _a1 error) *UserUsecase_LoginWithPhone_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserUsecase_LoginWithPhone_Call) RunAndReturn(run func(context.Context, string, string) (*models.User, error)) *UserUsecase_LoginWithPhone_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// LoginWithUsername provides a mock function with given fields: ctx, username, password
func (_m *UserUsecase) LoginWithUsername(ctx context.Context, username string, password string) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, username, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for LoginWithUsername")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, username, password)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, username, password)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, username, password)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UserUsecase_LoginWithUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginWithUsername'
type UserUsecase_LoginWithUsername_Call struct {
        *mock.Call
}

// LoginWithUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - password string
func (_e *UserUsecase_Expecter) LoginWithUsername(ctx interface{}, username interface{}, password interface{}) *UserUsecase_LoginWithUsername_Call <span class="cov0" title="0">{
        return &amp;UserUsecase_LoginWithUsername_Call{Call: _e.mock.On("LoginWithUsername", ctx, username, password)}
}</span>

func (_c *UserUsecase_LoginWithUsername_Call) Run(run func(ctx context.Context, username string, password string)) *UserUsecase_LoginWithUsername_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserUsecase_LoginWithUsername_Call) Return(_a0 *models.User, _a1 error) *UserUsecase_LoginWithUsername_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserUsecase_LoginWithUsername_Call) RunAndReturn(run func(context.Context, string, string) (*models.User, error)) *UserUsecase_LoginWithUsername_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// RegisterUser provides a mock function with given fields: ctx, data
func (_m *UserUsecase) RegisterUser(ctx context.Context, data entities.UserData) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, data)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for RegisterUser")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, entities.UserData) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, data)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, entities.UserData) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, data)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, entities.UserData) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, data)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UserUsecase_RegisterUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterUser'
type UserUsecase_RegisterUser_Call struct {
        *mock.Call
}

// RegisterUser is a helper method to define mock.On call
//   - ctx context.Context
//   - data entities.UserData
func (_e *UserUsecase_Expecter) RegisterUser(ctx interface{}, data interface{}) *UserUsecase_RegisterUser_Call <span class="cov0" title="0">{
        return &amp;UserUsecase_RegisterUser_Call{Call: _e.mock.On("RegisterUser", ctx, data)}
}</span>

func (_c *UserUsecase_RegisterUser_Call) Run(run func(ctx context.Context, data entities.UserData)) *UserUsecase_RegisterUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(entities.UserData))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserUsecase_RegisterUser_Call) Return(_a0 *models.User, _a1 error) *UserUsecase_RegisterUser_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserUsecase_RegisterUser_Call) RunAndReturn(run func(context.Context, entities.UserData) (*models.User, error)) *UserUsecase_RegisterUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewUserUsecase creates a new instance of UserUsecase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUserUsecase(t interface {
        mock.TestingT
        Cleanup(func())
}) *UserUsecase <span class="cov0" title="0">{
        mock := &amp;UserUsecase{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package models

import (
        "app/internal/consts"
        "app/internal/utils"
        "errors"
        "fmt"
        "time"

        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

type User struct {
        gorm.Model
  Fullname    string 
  PhoneNumber string `gorm:"unique"`
  Email       string `gorm:"unique"`
  Username    string `gorm:"unique"`
        Password    string
        Birthday    time.Time
        LatestLogin time.Time
}

// Hash password before insert into database
func (u *User) BeforeCreate(tx *gorm.DB) (err error)  <span class="cov0" title="0">{
  u.Password, err = utils.HashPassword(u.Password)

  if err != nil </span><span class="cov0" title="0">{
    if errors.Is(err, bcrypt.ErrPasswordTooLong) </span><span class="cov0" title="0">{
      err = consts.NewError(fmt.Errorf("password too long; %v", err))
      return
    }</span>
    <span class="cov0" title="0">if errors.Is(err, bcrypt.ErrHashTooShort) </span><span class="cov0" title="0">{
      err = consts.NewError(fmt.Errorf("password too short; %v", err))
      return
    }</span>
    <span class="cov0" title="0">err = consts.NewError(fmt.Errorf("failed to hash password; %v", err))</span>
  }
  <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package utils

import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package utils

import (
        "app/internal/consts"

        "github.com/gin-gonic/gin"
)


// Wrap function for binding request and handle error
// handlerTag should be the function call 
func BindRequest(c *gin.Context, request interface{}, handlerTag string) error <span class="cov8" title="1">{
        if err := c.BindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                err = consts.ErrInvalidRequest.WithRootCause(err).WithTag("handler",handlerTag)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package utils

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type ResponseObject struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data"`
}

func ResponseWithJSON(c *gin.Context, data interface{}) <span class="cov8" title="1">{
        if gin.IsDebugging() </span><span class="cov0" title="0">{
                c.IndentedJSON(http.StatusOK, ResponseObject{Success: true, Data: data})
        }</span> else<span class="cov8" title="1"> {
                c.JSON(http.StatusOK, ResponseObject{Success: true, Data: data})
        }</span>
}

</pre>
		
		<pre class="file" id="file25" style="display: none">package main

import (
        "app/cmd"
)

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
