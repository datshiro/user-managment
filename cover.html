
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">app/cmd/root.go (0.0%)</option>
				
				<option value="file1">app/cmd/server.go (0.0%)</option>
				
				<option value="file2">app/cmd/version.go (0.0%)</option>
				
				<option value="file3">app/internal/common/helper/api_error.go (44.4%)</option>
				
				<option value="file4">app/internal/common/http/response/options.go (100.0%)</option>
				
				<option value="file5">app/internal/common/http/response/wrapper.go (91.7%)</option>
				
				<option value="file6">app/internal/consts/errors.go (7.4%)</option>
				
				<option value="file7">app/internal/handler/v1/auth/handler.go (39.3%)</option>
				
				<option value="file8">app/internal/handler/v1/auth/request.go (50.0%)</option>
				
				<option value="file9">app/internal/infras/app/app.go (0.0%)</option>
				
				<option value="file10">app/internal/infras/app/middlewares/error.go (100.0%)</option>
				
				<option value="file11">app/internal/infras/app/option.go (0.0%)</option>
				
				<option value="file12">app/internal/infras/app/routing.go (0.0%)</option>
				
				<option value="file13">app/internal/infras/database/db.go (0.0%)</option>
				
				<option value="file14">app/internal/infras/database/option.go (15.4%)</option>
				
				<option value="file15">app/internal/infras/database/postgres_connection.go (0.0%)</option>
				
				<option value="file16">app/internal/infras/redis/redis.go (0.0%)</option>
				
				<option value="file17">app/internal/interfaces/repositories/models/user.go (63.6%)</option>
				
				<option value="file18">app/internal/interfaces/repositories/user/cache.go (81.2%)</option>
				
				<option value="file19">app/internal/interfaces/repositories/user/user.go (82.9%)</option>
				
				<option value="file20">app/internal/interfaces/usecases/usecases.go (100.0%)</option>
				
				<option value="file21">app/internal/interfaces/usecases/user/user.go (38.9%)</option>
				
				<option value="file22">app/internal/mocks/repositories/user/UserRepository.go (0.0%)</option>
				
				<option value="file23">app/internal/mocks/usecases/user/UserUsecase.go (19.2%)</option>
				
				<option value="file24">app/internal/utils/password.go (50.0%)</option>
				
				<option value="file25">app/internal/utils/request.go (0.0%)</option>
				
				<option value="file26">app/internal/utils/response.go (0.0%)</option>
				
				<option value="file27">app/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

var (
        rootCmd = &amp;cobra.Command{}
)

func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "app/internal/infras/app"
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/caarlos0/env/v11"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

func init() <span class="cov0" title="0">{
        // Load environment variables
        viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err == nil </span><span class="cov0" title="0">{
                fmt.Println("Using config file:", viper.ConfigFileUsed())
        }</span>

        // serverCommand.Flags().IntVarP(&amp;serverCfg.Port, "port", "p", serverCfg.Port, "port number to run on")
        // serverCommand.Flags().StringVar(&amp;serverCfg.ApiPrefix, "prefix", serverCfg.ApiPrefix, "API prefix")
        <span class="cov0" title="0">rootCmd.AddCommand(serverCommand)</span>
}

var (
        err       error

        serverCommand = &amp;cobra.Command{
                Use:   "server",
                Short: "Run App API Server",
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        server := app.NewApp()

                        // Create a signal channel and start server in a goroutine
                        signChan := make(chan os.Signal, 1)
                        go func() </span><span class="cov0" title="0">{
                                if err := server.Start(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                        log.Fatalf("server.Start: %v", err)
                                }</span>
                        }()

                        // Listen to terminate signal from system or os
                        <span class="cov0" title="0">signal.Notify(signChan, os.Interrupt, syscall.SIGTERM)
                        &lt;-signChan
                        log.Println("shutting down")

                        waitTime := 2 * time.Second
                        ctx, cancel := context.WithTimeout(context.Background(), waitTime)
                        defer func() </span><span class="cov0" title="0">{
                                log.Println("Closing Database connection!")
                                cancel()
                        }</span>()

                        // Stop server
                        <span class="cov0" title="0">log.Println("Stopping http server....")
                        if err := server.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                                log.Println("Halted active connections")
                        }</span>
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                log.Printf("timeout for %v seconds", waitTime)</span>
                        }
                        <span class="cov0" title="0">log.Printf("Shudown completed!")</span>
                },
        }
)

func LoadConfig() (app.Opts, error) <span class="cov0" title="0">{
        c := app.Opts{}

        if err := env.Parse(&amp;c); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%+v\n", err)
        }</span>
        <span class="cov0" title="0">log.Printf("%+v\n", c)
        return c, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
)

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(versionCmd)
}</span>

var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Print the version number of app",
        Long:  `All software has versions. This is an api server version`,
  Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
    fmt.Println("App 1.0.0")
  }</span>,
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package helper

import (
        "fmt"
        "net/http"
)

type APIError struct {
        StatusCode int   `json:"status_code"`
        Message    any   `json:"message"`
        details    error 
}

func (e APIError) WithDetails(err error) APIError <span class="cov8" title="1">{
        e.details = err
        return e
}</span>

func (e APIError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("api error: %d; %s", e.StatusCode, e.Message)
}</span>

func NewAPIError(statusCode int, err error) APIError <span class="cov8" title="1">{
        return APIError{StatusCode: statusCode, Message: err.Error()}
}</span>

func InvalidJSON() APIError <span class="cov0" title="0">{
        return NewAPIError(http.StatusBadRequest, fmt.Errorf("invalid request JSON data"))
}</span>

func InvalidValidationErrors(errs map[string]error) APIError <span class="cov0" title="0">{
  messages := make(map[string]string)
  for k,v := range errs </span><span class="cov0" title="0">{
    messages[k] = v.Error()
  }</span>
        <span class="cov0" title="0">return APIError{StatusCode: http.StatusUnprocessableEntity, Message: messages}</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package response

type Opts struct {
  Code int
}

func defaultOpts() Opts <span class="cov8" title="1">{
  return Opts{}
}</span>

type OptFunc func(*Opts)

func WithCode(code int ) OptFunc  <span class="cov8" title="1">{
  return func(o *Opts) </span><span class="cov8" title="1">{
    o.Code = code
  }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package response

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type Wrapper interface {
        JSON(data interface{})
        Error(code int, err error)
}

func New(c *gin.Context, opts ...OptFunc) Wrapper <span class="cov8" title="1">{
        o := defaultOpts()

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;o)
        }</span>
        <span class="cov8" title="1">return &amp;wrapper{ctx: c, Opts: o}</span>
}

type wrapper struct {
        ctx *gin.Context
        Opts
        // Extend logger later
}

func (w *wrapper) JSON(data interface{}) <span class="cov8" title="1">{
        var code  = http.StatusOK
        if w.Code != 0 </span><span class="cov8" title="1">{
                code = w.Code
        }</span>
        <span class="cov8" title="1">if gin.IsDebugging() </span><span class="cov0" title="0">{
                w.ctx.IndentedJSON(code, ResponseObject{StatusCode: code, Data: data})
        }</span> else<span class="cov8" title="1"> {
                w.ctx.JSON(code, ResponseObject{StatusCode: code, Data: data})
        }</span>
}

func (w *wrapper) Error(code int, err error) <span class="cov8" title="1">{
        message := err.Error()
        w.ctx.AbortWithStatusJSON(code, ResponseObject{StatusCode: code, Message: message})
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package consts

import (
        "fmt"
        "net/http"
)

// Custom error type for internal service
// this struct must be initialize via 
type CustomError struct {
        root     error
        err      error
        args     []interface{}
        tags     map[string]interface{}
        httpCode int
}

func NewError(err error, args ...interface{}) CustomError <span class="cov8" title="1">{
        return CustomError{root: err, err: err, tags: map[string]interface{}{}}
}</span>

// Error message is combination of message, args and tags
func (e CustomError) Error() string <span class="cov0" title="0">{
        var msg string
        re, ok := e.root.(CustomError)
        if ok </span><span class="cov0" title="0">{
                msg += fmt.Sprintf("%v; ", re.Error())
        }</span>
        <span class="cov0" title="0">if e.err != nil </span><span class="cov0" title="0">{
                msg += fmt.Sprintf("%v; ", e.err.Error())
        }</span>
        <span class="cov0" title="0">for _, arg := range e.args </span><span class="cov0" title="0">{
                msg += fmt.Sprintf(" %+v; ", arg)
        }</span>

        <span class="cov0" title="0">return msg</span>
}

// Add tag to error for additional info, which useful for log and tracing
func (e CustomError) WithTag(key string, value interface{}) CustomError <span class="cov0" title="0">{
        e.tags[key] = value
        return e
}</span>

// set root cause error
func (e CustomError) WithRootCause(err error) CustomError <span class="cov0" title="0">{
        e.root = err
        return e
}</span>

func (e CustomError) Details() string <span class="cov0" title="0">{
        var msg string
        if e.root != nil </span><span class="cov0" title="0">{
                msg += e.root.Error()
        }</span>
        <span class="cov0" title="0">for tag, value := range e.tags </span><span class="cov0" title="0">{
                msg += fmt.Sprintf("; %s=%+v", tag, value)
        }</span>
        <span class="cov0" title="0">return msg</span>
}

// Set HTTP Status Code which will set to header in response
func (e CustomError) WithHttpCode(code int) CustomError <span class="cov0" title="0">{
        e.httpCode = code
        return e
}</span>

// Set HTTP Status Code which will set to header in response
func (e CustomError) GetCode() int <span class="cov0" title="0">{
        if e.httpCode == 0 </span><span class="cov0" title="0">{
                return http.StatusBadRequest // 400 as default
        }</span>
        <span class="cov0" title="0">return e.httpCode</span>
}

// Init error with error type
func withError(err error, args ...interface{}) CustomError <span class="cov0" title="0">{
        return NewError(err, args...)
}</span>

// Init error with string message
func withMessage(msg string, args ...interface{}) CustomError <span class="cov8" title="1">{
        return NewError(fmt.Errorf(msg), args...)
}</span>

var (
        ErrInvalidRequest        = withMessage("Invalid request")
        ErrCreateFailure         = withMessage("Create failure")
        ErrLoginFailure          = withMessage("Login Failure")
        ErrDataNotFound          = withMessage("Requesting resource not found")
        ErrMissingCredentialInfo = withMessage("account info cannot be empty, please provide username, email or phone number")
        ErrPasswordCannotBeEmpty = withMessage("password cannot be empty")
)
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "app/internal/common/helper"
        "app/internal/common/http/response"
        "app/internal/interfaces/repositories/models"
        "app/internal/interfaces/usecases/user"
        "errors"
        "net/http"

        "github.com/gin-gonic/gin"
        "gorm.io/gorm"
)

type AuthHandler interface {
        HandleLogin(*gin.Context)
        HandleRegister(*gin.Context)
}

type handler struct {
        uc user.UserUsecase
}

func NewHandler(uc user.UserUsecase) AuthHandler <span class="cov8" title="1">{
        return handler{uc}
}</span>

// Handlers
func (h handler) HandleLogin(c *gin.Context) <span class="cov0" title="0">{
        var req = LoginRequest{}

        if err := c.BindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
    c.Error(helper.InvalidJSON())
                return
        }</span>

  <span class="cov0" title="0">if errs := req.Validate() ; errs != nil </span><span class="cov0" title="0">{
    c.Error(helper.InvalidValidationErrors(errs))
    return
  }</span>

        <span class="cov0" title="0">user, err := h.uc.LoginWithEmail(c.Request.Context(), req.Email, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
      c.Error(helper.NewAPIError(http.StatusNotFound, errors.New("user is not exist")))
                        return
                }</span>
    <span class="cov0" title="0">c.Error(err)
                return</span>
        }

        // TODO: generate token

  <span class="cov0" title="0">c.JSON(http.StatusOK, map[string]any{
    "email": user.Email,
    "birthday": user.Birthday,
    "phone": user.PhoneNumber,
  })</span>
}

func (h handler) HandleRegister(c *gin.Context) <span class="cov8" title="1">{
        var req = &amp;models.User{}

        if err := c.BindJSON(req); err != nil </span><span class="cov0" title="0">{
    c.Error(helper.InvalidJSON().WithDetails(err))
                return
        }</span>

        <span class="cov8" title="1">if err := ValidateRegisterRequest(req); err != nil </span><span class="cov8" title="1">{
    c.Error(helper.InvalidValidationErrors(err))
    return
        }</span>

        <span class="cov8" title="1">user, err := h.uc.RegisterUser(c.Request.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                response.New(c).Error(http.StatusConflict, err)
                return
        }</span>

        <span class="cov8" title="1">response.New(c, response.WithCode(http.StatusCreated)).JSON(user)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package auth

import (
        "app/internal/interfaces/repositories/models"
        "errors"

        validation "github.com/go-ozzo/ozzo-validation/v4"
        "github.com/go-ozzo/ozzo-validation/v4/is"
)

type LoginRequest struct {
        Email    string `json:"email" form:"email"`
        Password string `json:"password" form:"password"`
}

func (req LoginRequest) Validate() map[string]error <span class="cov0" title="0">{
  errs := make(map[string]error)
        if err := validation.Validate(req.Email, validation.Required, is.Email); err != nil </span><span class="cov0" title="0">{
                errs["email"] = errors.New("email must not be empty")
        }</span>

        <span class="cov0" title="0">if err := validation.Validate(req.Password, validation.Required); err != nil </span><span class="cov0" title="0">{
                errs["password"] = errors.New("email must not be empty")
        }</span>
  <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
    return errs
  }</span>
  <span class="cov0" title="0">return nil</span>
}

func ValidateRegisterRequest(user *models.User) map[string]error <span class="cov8" title="1">{
  errs := make(map[string]error) 
        if err := validation.Validate(user.Email, validation.Required); err != nil </span><span class="cov8" title="1">{
                errs["message"] = errors.New("email must not be empty")
        }</span>
        <span class="cov8" title="1">if err := validation.Validate(user.Email, is.Email); err != nil </span><span class="cov0" title="0">{
                errs["email_format"] = errors.New("email is in correct format")
        }</span>
        <span class="cov8" title="1">if err := validation.Validate(user.Password, validation.Required); err != nil </span><span class="cov8" title="1">{
                errs["password"] = errors.New("password must not be empty")
        }</span>
  <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov8" title="1">{
    return errs
  }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package app

import (
        "app/internal/infras/app/middlewares"
        "app/internal/infras/database"
        rd "app/internal/infras/redis"
        "app/internal/interfaces/repositories/user"
        "app/internal/interfaces/usecases"
        "context"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/redis/go-redis/v9"
        "gorm.io/gorm"
)

type App interface {
        Start() error
        Stop(ctx context.Context) error
}

type app struct {
        engine *gin.Engine
        srv    *http.Server
        cfg    Opts
        dbc    *gorm.DB
        rdc    *redis.Client
}

func (s *app) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return s.srv.Shutdown(ctx)
}</span>

func NewApp(opts ...OptFunc) App <span class="cov0" title="0">{
        engine := gin.Default()
        o := defaultOpts()

        for _, optFunc := range opts </span><span class="cov0" title="0">{
                optFunc(&amp;o)
        }</span>

        <span class="cov0" title="0">a := &amp;app{
                engine: engine,
                srv: &amp;http.Server{
                        Handler: engine,
                        Addr:    fmt.Sprintf(":%d", o.Port),
                },
        }

        if o.DatabaseEnable </span><span class="cov0" title="0">{
                a.dbc = database.NewPostgresConnection()
        }</span>
  <span class="cov0" title="0">if o.RedisEnable </span><span class="cov0" title="0">{
    a.rdc = rd.NewRedis()
  }</span>
        <span class="cov0" title="0">repo := user.NewRepo(a.dbc, a.rdc)
        usecase := usecases.NewPostgresUsecase(repo)

        // Routers
        routing(engine, o.ApiPrefix, usecase)
        return a</span>
}

func (s *app) Start() error <span class="cov0" title="0">{
        // Middlwares
        s.engine.Use(gin.Recovery())
        s.engine.Use(middlewares.ErrorHandlerMiddleware())

        return s.srv.ListenAndServe()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package middlewares

import (
        "app/internal/common/helper"
        "log/slog"
        "net/http"

        "github.com/gin-gonic/gin"
)

func ErrorHandlerMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                c.Next()

    for _, err := range c.Errors </span><span class="cov8" title="1">{
                        apiErr, ok := err.Err.(helper.APIError)
                        if ok </span><span class="cov8" title="1">{
        c.AbortWithStatusJSON(apiErr.StatusCode, apiErr)
        return
                        }</span> else<span class="cov8" title="1"> {
        c.AbortWithStatusJSON(http.StatusInternalServerError, map[string]any {
          "status_code": http.StatusInternalServerError,
          "message": "internal server error",
        })
      }</span>
      <span class="cov8" title="1">slog.Error("HTTP API error", "err", err, "path", c.Request.URL.Path)</span>
    }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package app

import (
        "fmt"
        "log"

        "github.com/caarlos0/env/v11"
)

type Opts struct {
        Port                  int    `env:"PORT" envDefault:"3333"`
        ApiPrefix             string `env:"API_PREFIX" envPrefix:"api"`
        DatabaseEnable        bool   `env:"DATABASE_ENABLE" envDefault:"false"`
        RedisEnable           bool   `env:"REDIS_ENABLE" envDefault:"false"`
        RedisConnectionString string `env:"REDIS_CONNECTION_STRING"`
}

func defaultOpts() Opts <span class="cov0" title="0">{
        c := Opts{
                Port:                  3000,
                RedisConnectionString: "redis://0.0.0.0:6379",
                ApiPrefix:             "api",
                DatabaseEnable:        false,
                RedisEnable:           false,
        }

        if err := env.Parse(&amp;c); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%+v\n", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("%+v\n", c)

        return c</span>
}

type OptFunc func(*Opts)

func WithPort(port int) OptFunc <span class="cov0" title="0">{
        return func(c *Opts) </span><span class="cov0" title="0">{
                c.Port = port
        }</span>
}

func WithDatabase(isConnectDatabase bool) OptFunc <span class="cov0" title="0">{
        return func(c *Opts) </span><span class="cov0" title="0">{
                c.DatabaseEnable = isConnectDatabase
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package app

import (
        "app/internal/handler/v1/auth"
        "app/internal/interfaces/usecases"

        "github.com/gin-gonic/gin"
)

func routing(engine *gin.Engine, apiPrefix string, usecase usecases.Usecases) <span class="cov0" title="0">{
        router := engine.Group(apiPrefix)

        </span><span class="cov0" title="0">{
                authHandler := auth.NewHandler(usecase.UserUC)

    // /auth/*
                authRouter := router.Group("auth")
                authRouter.POST("/register", authHandler.HandleRegister)
                authRouter.POST("/login", authHandler.HandleLogin)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "app/internal/interfaces/repositories/models"
        "log"

        "gorm.io/gorm"
)

type DatabaseConnection interface {
        Connect() (*gorm.DB, error)
}

func NewPostgresConnection(opts ...OptFunc) *gorm.DB <span class="cov0" title="0">{
        o := Opts{}
        for _, optFunc := range opts </span><span class="cov0" title="0">{
                optFunc(&amp;o)
        }</span>

        <span class="cov0" title="0">dbConnection := &amp;PostgresConnection{Opts: o}

        postgresDbc, err := dbConnection.Connect()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect database ; %v", err)
        }</span>

        // Migrate the schema
        <span class="cov0" title="0">postgresDbc.AutoMigrate(&amp;models.User{})
        // End of migration

        return postgresDbc</span>
}

func ClosePostgresConnection() error <span class="cov0" title="0">{
        db, err := postgresDbc.DB()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">db.Close()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package database

import (
        "fmt"
        "log"

        "github.com/caarlos0/env/v11"
        "gorm.io/gorm"
)

type Opts struct {
        DB        string `env:"DATABASE_DB"`
        User      string `env:"DATABASE_USER"`
        Password  string `env:"DATABASE_PASSWORD"`
        Host      string `env:"DATABASE_HOST"`
        Port      string `env:"DATABASE_PORT"`
        SSLMode   string `env:"DATABASE_SSL_MODE" default:"disable"`
        TimeZone  string `env:"DATABASE_TIME_ZONE" default:"Asia/Shanghai"`
        Dialector gorm.Dialector
}
type OptFunc func(*Opts)

func LoadOpts() Opts <span class="cov0" title="0">{
        c := Opts{}

        if err := env.Parse(&amp;c); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("%+v\n", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("%+v\n", c)
        return c</span>

}

// db_type must be postgres or other database type
func (opt *Opts) GetDSN() string <span class="cov8" title="1">{
        dsn := "host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=%s"
        return fmt.Sprintf(dsn, opt.Host, opt.User, opt.Password, opt.DB, opt.Port, opt.SSLMode, opt.TimeZone)
}</span>

func WithUser(user string) OptFunc <span class="cov0" title="0">{
  return func(o *Opts) </span><span class="cov0" title="0">{
    o.User = user
  }</span>
}

func WithPassword(pass string) OptFunc <span class="cov0" title="0">{
  return func(o *Opts) </span><span class="cov0" title="0">{
    o.Password = pass
  }</span>
}

func WithDB(db_name string) OptFunc <span class="cov0" title="0">{
  return func(o *Opts) </span><span class="cov0" title="0">{
    o.DB = db_name
  }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package database

import (
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

var postgresDbc *gorm.DB

type PostgresConnection struct {
        Opts
}

func (p *PostgresConnection) Connect() (*gorm.DB, error) <span class="cov0" title="0">{
        p.Dialector = postgres.Open(p.GetDSN())
        client, err := gorm.Open(p.Dialector, &amp;gorm.Config{})
        return client, err
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package redis

import "github.com/redis/go-redis/v9"

func NewRedis(opts ...OptFunc) *redis.Client <span class="cov0" title="0">{
        o := Opts{}
        connOpts, err := redis.ParseURL(o.ConnectionString)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return redis.NewClient(connOpts)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

import (
        "app/internal/utils"
        "errors"
        "time"

        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

var (
  ErrPasswordTooLong = errors.New("password: too long for hashing")
  ErrPasswordTooShort = errors.New("password: too short for hashing")
  ErrPasswordHash = errors.New("password: hash failed")
)

type User struct {
        gorm.Model
        Fullname    string
        PhoneNumber string `gorm:"not_null"`
        Email       string `gorm:"unique"`
        Password    string `gorm:"not_null"`
        Birthday    time.Time
        LatestLogin time.Time
}

// Hash password before insert into database
func (u *User) BeforeCreate(tx *gorm.DB) (err error) <span class="cov8" title="1">{
  if len(u.Password) &lt; 7 </span><span class="cov8" title="1">{
    return ErrPasswordTooShort
  }</span>
        <span class="cov8" title="1">u.Password, err = utils.HashPassword(u.Password)

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, bcrypt.ErrPasswordTooLong) </span><span class="cov8" title="1">{
                        return ErrPasswordTooLong
                }</span>
                <span class="cov0" title="0">if errors.Is(err, bcrypt.ErrHashTooShort) </span><span class="cov0" title="0">{
                        return ErrPasswordTooShort
                }</span>
          <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (u *User) ComparePassword(password string) bool <span class="cov0" title="0">{
  return utils.CheckPasswordHash(password, u.Password)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package user

import (
        "app/internal/interfaces/repositories/models"
        "context"
        "fmt"
        "strconv"
        "time"

        "gorm.io/gorm"
)

func getIdKey(id uint) string <span class="cov8" title="1">{
        return fmt.Sprintf("users:%d", id)
}</span>
func getEmailKey(email string) string <span class="cov8" title="1">{
        return fmt.Sprintf("users:%s", email)
}</span>

func (repo *userRepo) convertMapToUse(mapUser map[string]string) (models.User, error) <span class="cov8" title="1">{
        userID, err := strconv.Atoi(mapUser["id"])
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, err
        }</span>

        <span class="cov8" title="1">createdAt, err := time.Parse(time.RFC3339Nano, mapUser["created_at"])
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, err
        }</span>

        <span class="cov8" title="1">updatedAt, err := time.Parse(time.RFC3339Nano, mapUser["updated_at"])
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, err
        }</span>

        <span class="cov8" title="1">birthDay, err := time.Parse(time.RFC3339Nano, mapUser["birthday"])
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, err
        }</span>

        <span class="cov8" title="1">latestLogin, err := time.Parse(time.RFC3339Nano, mapUser["latest_login"])
        if err != nil </span><span class="cov0" title="0">{
                return models.User{}, err
        }</span>

        <span class="cov8" title="1">user := models.User{
                Model: gorm.Model{
                        ID:        uint(userID),
                        CreatedAt: createdAt,
                        UpdatedAt: updatedAt,
                },
                Fullname:    mapUser["fullname"],
                PhoneNumber: mapUser["phone_number"],
                Email:       mapUser["email"],
                Password:    mapUser["password"],
                Birthday:    birthDay,
                LatestLogin: latestLogin,
        }
        return user, nil</span>
}

func (repo *userRepo) cacheUser(user models.User) error <span class="cov8" title="1">{
        idKey := getIdKey(user.ID)
        emailKey := getEmailKey(user.Email)
        cachedUser := map[string]any{
                "id":           user.ID,
                "email":        user.Email,
                "fullname":     user.Fullname,
                "phone_number": user.PhoneNumber,
                "password":     user.Password,
                "birthday":     user.Birthday,
                "created_at":   user.CreatedAt,
                "updated_at":   user.UpdatedAt,
                "latest_login": user.LatestLogin,
        }

        for key, value := range cachedUser </span><span class="cov8" title="1">{
                if err := repo.rd.HSet(context.Background(), idKey, key, value).Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := repo.rd.HSet(context.Background(), emailKey, key, value).Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (repo *userRepo) getUserFromCache(ctx context.Context, id int) *models.User <span class="cov8" title="1">{
        result := repo.rd.HGetAll(ctx, getIdKey(uint(id))).Val()
        if len(result) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">user, err := repo.convertMapToUse(result)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;user</span>
}

func (repo *userRepo) getUserFromCacheByEmail(ctx context.Context, email string) *models.User <span class="cov8" title="1">{
        result := repo.rd.HGetAll(ctx, getEmailKey(email)).Val()
        if len(result) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">user, err := repo.convertMapToUse(result)
        if err != nil </span><span class="cov0" title="0">{
    panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;user</span>
}

func (repo *userRepo) deleteFromCache(ctx context.Context, user models.User) error <span class="cov8" title="1">{
        keysToDelete := make([]string, 0)
        if user.ID &gt; 0 </span><span class="cov8" title="1">{
                keysToDelete = append(keysToDelete, getIdKey(user.ID))
        }</span>
        <span class="cov8" title="1">if user.Email != "" </span><span class="cov8" title="1">{
                keysToDelete = append(keysToDelete, getEmailKey(user.Email))
        }</span>
        <span class="cov8" title="1">return repo.rd.Del(ctx, keysToDelete...).Err()</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package user

import (
        "app/internal/interfaces/repositories/models"
        "context"
        "errors"
        "github.com/redis/go-redis/v9"

        "gorm.io/gorm"
)

type UserRepository interface {
        SaveUser(ctx context.Context, user *models.User) error
        GetUser(ctx context.Context, id int) (*models.User, error)
        GetUserByEmail(ctx context.Context, email string) (*models.User, error)
        DeleteUser(ctx context.Context, id int) error
}

func NewRepo(dbc *gorm.DB, rd *redis.Client) UserRepository <span class="cov8" title="1">{
        return &amp;userRepo{dbc, rd}
}</span>

type userRepo struct {
        dbc *gorm.DB
        rd  *redis.Client
}

func (repo *userRepo) SaveUser(ctx context.Context, data *models.User) error <span class="cov8" title="1">{
        // remove from cache
        if err := repo.deleteFromCache(ctx, *data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // save user
        <span class="cov8" title="1">result := repo.dbc.Save(&amp;data)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (repo *userRepo) GetUser(ctx context.Context, id int) (*models.User, error) <span class="cov8" title="1">{
        // get from cache
        cachedUser := repo.getUserFromCache(ctx, id)
        if cachedUser != nil </span><span class="cov8" title="1">{
                return cachedUser, nil
        }</span>

        // Get user from database
        <span class="cov8" title="1">user := models.User{Model: gorm.Model{ID: uint(id)}}
        result := repo.dbc.First(&amp;user)
        if result.Error != nil </span><span class="cov8" title="1">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, result.Error</span>
        }

        // cache retrieved user
        <span class="cov8" title="1">if err := repo.cacheUser(user); err != nil </span><span class="cov0" title="0">{
                return &amp;user, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (repo *userRepo) GetUserByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov8" title="1">{
        // Get User from cache
        cachedUser := repo.getUserFromCacheByEmail(ctx, email)
        if cachedUser != nil </span><span class="cov8" title="1">{
                return cachedUser, nil
        }</span>

        // Get from database
        <span class="cov8" title="1">user := models.User{Email: email}
        result := repo.dbc.First(&amp;user)
        if result.Error != nil </span><span class="cov8" title="1">{
                return nil, result.Error
        }</span>

        // cache retreived user
        <span class="cov8" title="1">if err := repo.cacheUser(user); err != nil </span><span class="cov0" title="0">{
                return &amp;user, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (repo *userRepo) DeleteUser(ctx context.Context, id int) error <span class="cov8" title="1">{
        // Delete from cache
        cachedUser := repo.getUserFromCache(ctx, id)
        if cachedUser != nil </span><span class="cov8" title="1">{
                if err := repo.deleteFromCache(ctx, *cachedUser); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">result := repo.dbc.Delete(&amp;models.User{}, id)
        return result.Error</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package usecases

import (
        user_repo "app/internal/interfaces/repositories/user"
        "app/internal/interfaces/usecases/user"

)

type Usecases struct {
  UserUC user.UserUsecase 
}

func NewPostgresUsecase(userRepo user_repo.UserRepository) Usecases <span class="cov8" title="1">{
  return Usecases{
    UserUC: user.NewUseCase(userRepo),
  }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package user

import (
        "app/internal/interfaces/repositories/models"
        "app/internal/interfaces/repositories/user"
        "context"
        "errors"
        "time"

        "gorm.io/gorm"
)

var (
        ErrInvalidPassword = errors.New("login: password is incorrect")
  ErrUserExisted = errors.New("create: user is already existed")
)

type UserUsecase interface {
        LoginWithEmail(ctx context.Context, email string, password string) (*models.User, error)
        RegisterUser(ctx context.Context, data *models.User) (*models.User, error)
}

func NewUseCase(repo user.UserRepository) UserUsecase <span class="cov8" title="1">{
        return &amp;userUsecase{repo: repo}
}</span>

type userUsecase struct {
        repo user.UserRepository
}

func (uc *userUsecase) LoginWithEmail(ctx context.Context, email string, password string) (*models.User, error) <span class="cov0" title="0">{
        user, err := uc.repo.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !user.ComparePassword(password) </span><span class="cov0" title="0">{
                return nil, ErrInvalidPassword
        }</span>

        <span class="cov0" title="0">user.LatestLogin = time.Now()
        err = uc.repo.SaveUser(ctx, user)
        return user, err</span>
}

func (uc *userUsecase) RegisterUser(ctx context.Context, data *models.User) (*models.User, error) <span class="cov8" title="1">{
        // Check if user existed
        u, err := uc.repo.GetUserByEmail(ctx, data.Email)
        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
  <span class="cov8" title="1">if u != nil </span><span class="cov0" title="0">{
    return nil, ErrUserExisted
  }</span>

        <span class="cov8" title="1">if err = uc.repo.SaveUser(ctx, data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by mockery. DO NOT EDIT.

package mocks

import (
        models "app/internal/interfaces/repositories/models"
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// UserRepository is an autogenerated mock type for the UserRepository type
type UserRepository struct {
        mock.Mock
}

type UserRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *UserRepository) EXPECT() *UserRepository_Expecter <span class="cov0" title="0">{
        return &amp;UserRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// DeleteUser provides a mock function with given fields: ctx, id
func (_m *UserRepository) DeleteUser(ctx context.Context, id int) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteUser")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// UserRepository_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type UserRepository_DeleteUser_Call struct {
        *mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *UserRepository_Expecter) DeleteUser(ctx interface{}, id interface{}) *UserRepository_DeleteUser_Call <span class="cov0" title="0">{
        return &amp;UserRepository_DeleteUser_Call{Call: _e.mock.On("DeleteUser", ctx, id)}
}</span>

func (_c *UserRepository_DeleteUser_Call) Run(run func(ctx context.Context, id int)) *UserRepository_DeleteUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserRepository_DeleteUser_Call) Return(_a0 error) *UserRepository_DeleteUser_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *UserRepository_DeleteUser_Call) RunAndReturn(run func(context.Context, int) error) *UserRepository_DeleteUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetUser provides a mock function with given fields: ctx, id
func (_m *UserRepository) GetUser(ctx context.Context, id int) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUser")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UserRepository_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type UserRepository_GetUser_Call struct {
        *mock.Call
}

// GetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *UserRepository_Expecter) GetUser(ctx interface{}, id interface{}) *UserRepository_GetUser_Call <span class="cov0" title="0">{
        return &amp;UserRepository_GetUser_Call{Call: _e.mock.On("GetUser", ctx, id)}
}</span>

func (_c *UserRepository_GetUser_Call) Run(run func(ctx context.Context, id int)) *UserRepository_GetUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserRepository_GetUser_Call) Return(_a0 *models.User, _a1 error) *UserRepository_GetUser_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserRepository_GetUser_Call) RunAndReturn(run func(context.Context, int) (*models.User, error)) *UserRepository_GetUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetUserByEmail provides a mock function with given fields: ctx, email
func (_m *UserRepository) GetUserByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, email)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByEmail")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UserRepository_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type UserRepository_GetUserByEmail_Call struct {
        *mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *UserRepository_Expecter) GetUserByEmail(ctx interface{}, email interface{}) *UserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        return &amp;UserRepository_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, email)}
}</span>

func (_c *UserRepository_GetUserByEmail_Call) Run(run func(ctx context.Context, email string)) *UserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserRepository_GetUserByEmail_Call) Return(_a0 *models.User, _a1 error) *UserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserRepository_GetUserByEmail_Call) RunAndReturn(run func(context.Context, string) (*models.User, error)) *UserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// SaveUser provides a mock function with given fields: ctx, _a1
func (_m *UserRepository) SaveUser(ctx context.Context, _a1 *models.User) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, _a1)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SaveUser")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.User) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, _a1)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// UserRepository_SaveUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveUser'
type UserRepository_SaveUser_Call struct {
        *mock.Call
}

// SaveUser is a helper method to define mock.On call
//   - ctx context.Context
//   - _a1 *models.User
func (_e *UserRepository_Expecter) SaveUser(ctx interface{}, _a1 interface{}) *UserRepository_SaveUser_Call <span class="cov0" title="0">{
        return &amp;UserRepository_SaveUser_Call{Call: _e.mock.On("SaveUser", ctx, _a1)}
}</span>

func (_c *UserRepository_SaveUser_Call) Run(run func(ctx context.Context, _a1 *models.User)) *UserRepository_SaveUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*models.User))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserRepository_SaveUser_Call) Return(_a0 error) *UserRepository_SaveUser_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *UserRepository_SaveUser_Call) RunAndReturn(run func(context.Context, *models.User) error) *UserRepository_SaveUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewUserRepository creates a new instance of UserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUserRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *UserRepository <span class="cov0" title="0">{
        mock := &amp;UserRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by mockery. DO NOT EDIT.

package mocks

import (
        models "app/internal/interfaces/repositories/models"
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// UserUsecase is an autogenerated mock type for the UserUsecase type
type UserUsecase struct {
        mock.Mock
}

type UserUsecase_Expecter struct {
        mock *mock.Mock
}

func (_m *UserUsecase) EXPECT() *UserUsecase_Expecter <span class="cov0" title="0">{
        return &amp;UserUsecase_Expecter{mock: &amp;_m.Mock}
}</span>

// LoginWithEmail provides a mock function with given fields: ctx, email, password
func (_m *UserUsecase) LoginWithEmail(ctx context.Context, email string, password string) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, email, password)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for LoginWithEmail")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, password)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, password)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, password)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// UserUsecase_LoginWithEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginWithEmail'
type UserUsecase_LoginWithEmail_Call struct {
        *mock.Call
}

// LoginWithEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
//   - password string
func (_e *UserUsecase_Expecter) LoginWithEmail(ctx interface{}, email interface{}, password interface{}) *UserUsecase_LoginWithEmail_Call <span class="cov0" title="0">{
        return &amp;UserUsecase_LoginWithEmail_Call{Call: _e.mock.On("LoginWithEmail", ctx, email, password)}
}</span>

func (_c *UserUsecase_LoginWithEmail_Call) Run(run func(ctx context.Context, email string, password string)) *UserUsecase_LoginWithEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserUsecase_LoginWithEmail_Call) Return(_a0 *models.User, _a1 error) *UserUsecase_LoginWithEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserUsecase_LoginWithEmail_Call) RunAndReturn(run func(context.Context, string, string) (*models.User, error)) *UserUsecase_LoginWithEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// RegisterUser provides a mock function with given fields: ctx, data
func (_m *UserUsecase) RegisterUser(ctx context.Context, data *models.User) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, data)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for RegisterUser")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.User) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, data)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *models.User) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, data)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *models.User) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, data)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UserUsecase_RegisterUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterUser'
type UserUsecase_RegisterUser_Call struct {
        *mock.Call
}

// RegisterUser is a helper method to define mock.On call
//   - ctx context.Context
//   - data *models.User
func (_e *UserUsecase_Expecter) RegisterUser(ctx interface{}, data interface{}) *UserUsecase_RegisterUser_Call <span class="cov0" title="0">{
        return &amp;UserUsecase_RegisterUser_Call{Call: _e.mock.On("RegisterUser", ctx, data)}
}</span>

func (_c *UserUsecase_RegisterUser_Call) Run(run func(ctx context.Context, data *models.User)) *UserUsecase_RegisterUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*models.User))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *UserUsecase_RegisterUser_Call) Return(_a0 *models.User, _a1 error) *UserUsecase_RegisterUser_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *UserUsecase_RegisterUser_Call) RunAndReturn(run func(context.Context, *models.User) (*models.User, error)) *UserUsecase_RegisterUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewUserUsecase creates a new instance of UserUsecase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUserUsecase(t interface {
        mock.TestingT
        Cleanup(func())
}) *UserUsecase <span class="cov0" title="0">{
        mock := &amp;UserUsecase{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package utils

import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package utils

import (
        "app/internal/consts"

        "github.com/gin-gonic/gin"
)


// Wrap function for binding request and handle error
// handlerTag should be the function call 
func BindRequest(c *gin.Context, request interface{}, handlerTag string) error <span class="cov0" title="0">{
        if err := c.BindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                err = consts.ErrInvalidRequest.WithRootCause(err).WithTag("handler",handlerTag)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package utils

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type ResponseObject struct {
        Message string      `json:"message,omitempty"`
        Data    interface{} `json:"data"`
}

func JSON(c *gin.Context, data interface{}) <span class="cov0" title="0">{
        if gin.IsDebugging() </span><span class="cov0" title="0">{
                c.IndentedJSON(http.StatusOK, ResponseObject{Data: data})
        }</span> else<span class="cov0" title="0"> {
                c.JSON(http.StatusOK, ResponseObject{Data: data})
        }</span>
}

func Error(c *gin.Context, code int, err error, data interface{}, messages ...string) <span class="cov0" title="0">{
        message := err.Error()
        for _, msg := range messages </span><span class="cov0" title="0">{
                message += msg
        }</span>
        <span class="cov0" title="0">c.JSON(code, ResponseObject{Data: data, Message: message})</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package main

import (
        "app/cmd"
)

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
